---
title: What new in ES2021 (aka ES13)?
date: 2022-04-29
---
<image src='../assets/es2021.jpg'/>

<br/>

If you missed out 'what new in the previous version of javascript?', you can check here [es6 - es11](/modern-javascript-what-new),and [es12](/what-new-in-es12).

Every year, javascript got the new update. ECMAScript 2022(ES2022) version is expected to be released soon. 

List down below is some new updates of ES2022 (aka ES13) that have been proposed in ECMAScript proposal (final stage):

<ul>
    <li><a href='#class-field-declarations'>Class field declarations</a></li>
    <li><a href='#private-methods-and-fields'>Private Methods and fields</a></li>
    <li><a href='#static-public-methods-and-fields'>Static public methods and fields</a></li>
    <li><a href='#regexp-match-indices'>Regexp Match Indices</a></li>
    <li><a href='#top-level-await'>Top-level await</a></li>
    <li><a href='#ergonomic-brand-checks-for-private-fields'>Ergonomic brand checks for Private Fields</a></li>
    <li><a href='#new-at-method-on-all-the-built-in-indexables'>New .at() method on all the built-in indexables</a></li>
    <li><a href='#object-accessible-objectprototypehasownproperty'>Object Accessible Object.prototype.hasOwnProperty()</a></li>
    <li><a href='#ecmascript-class-static-initialization-blocks'> ECMAScript class static initialization blocks </a></li>
</ul>

Credits:
1. [Brandon Lara article on medium](https://medium.com/geekculture/proposals-included-in-the-incoming-ecmascript-2022-standard-for-javascript-6119a4518904)
2. [ECMAScript proposal](https://github.com/tc39/proposals/blob/main/finished-proposals.md)
3. [Jasmin Virdi article on dev.to](https://dev.to/jasmin/whats-new-in-es2022-1de6)

---

### Class field declarations

In the previous version, in order to define and initialize the class field, we need to do it in side the ``` constructor method ```.
With the new proposal we can easily define and initialize the class field at the top level of the class.

>New approach

```jsx
class Class{
  instancePublicField = "This instance is predefined.";
}
```
> Old approach

```jsx
class PublicClass{
  constructor(value){
    this.instancePublicField = "This instance is predefined.";
    this.value = value;
  }
}

```
---
### Private Methods and fields
Private method and field can be created with prefix ``` # ```. Private Methods and Fields are only accessible inside its own class.

> Example

```jsx

class Car {
    #numberOfWheel = 4; // private field
    #carColor; //required
    static #staticPrivateField = "I am staticPrivateField."
    constructor(value){
      this.#carColor = value;
    }

    // this private method can access to private field 
    // cannot access the static private field
    #returnMyCar(){
      return `Your car is ${this.#carColor} and has ${this.#numberOfWheel} wheels.`
    }

    // public method can access the private method
    // cannot access static private method
    // and be accessed from the outside
    returnMyStringCar(){
      return this.#returnMyCar()
    }

    // static private method cannot access private field but can
    // access the private static field
    static #privateMethodCar(){
      return this.#staticPrivateField;
    }

    // static public method can access the static private method 
    // cannot access the private method
    // and be accessed from the outside
    static publicMethodCar(){
      return this.#privateMethodCar()
    }
}
const myCar = new Car('red');

myCar.carColor; // will return undefined;
myCar.#carColor; //Error: Private field '#carColor' must be declared in an enclosing class

Car.privateMethodCar(); //Error: myCar.privateMethodReturnCar is not a function
Car.#privateMethodCar(); //Error: Private field '#privateMethodReturnCar' must be declared in an enclosing class
Car.publicMethodCar(); //Will return 'I am staticPrivateField.'

myCar.returnMyStringCar(); //will return 'Your car is red and has 4 wheels.'

```
---

### Static public methods and fields
Private Accessors function start with ``` # ```.

```jsx
class Car {
  // Public accessor
  get name() { return 'Honda' }
  set name(value) {}

  // Private accessor
  get #color() { return 'red' }
  set #color(value) {}
}
```
We can access the Accessors as belows:

```jsx
const carObj = new Car();
console.log(carObj.name); // "Honda"
console.log(carObj.color); // undefined
```
---
### Regexp Match Indices
Logical assignment operator combines the logical operations(&&, || or ??) with assignment.

>TL-DR

```jsx
let a = 1;
let b = 2;
a ||= b;
// equivalent to a = a || b
console.log(a); // output: 1
```
```jsx
let c = 2;
let d = 5;
c &&= d;
// equivalent to c = c && d
console.log(c); // output: 5
```
```jsx
let e;
let f = 2;
e ??= f;
// equivalent to e = e ?? f
console.log(e) // output: 2

```
Let's see the summarize below:

- ``` a ||= b ``` will return ``` a ``` if ``` a ``` is ``` a ``` truthy value, or ``` b ``` if ``` a ``` is falsy
- ``` c &&= d ``` will return ``` d ``` if both ``` c ``` and ``` d ``` are truthy, or ``` c ``` otherwise
- ``` e ??= f ``` will return``` f ``` if ``` e ``` is ``` null ``` or  ``` undefined ``` otherwise it will return ``` e```

[Read More](https://github.com/tc39/proposal-logical-assignment)

---

### Top-level await

#### WeakRef

```WeakRef``` stands for Weak References. Main use of weak references is to implement caches or mappings to large objects.
For example: we don't want to keep a lot of memory for the rarely used cached or mapping so we can allow memory to be garbage collected and generate the fresh one if we need it.

Read More about javascript garbage collection [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management).

>TL-DR

To create WeakRef we just simply use ```new WeakRef``` and to call the weakref we can use ``` .deref() ```.

```jsx
const callback = () => {

  const aBigObj = new WeakRef({
    name: "Backbencher"
  });

  console.log(aBigObj.deref().name);
}

(async function(){
  await new Promise((resolve) => {
    setTimeout(() => {
      callback(); // Guaranteed to print "Backbencher"
      resolve();
    }, 2000);
  });

  await new Promise((resolve) => {
    setTimeout(() => {
      callback(); // No Gaurantee that "Backbencher" is printed
      resolve();
    }, 5000);
  });
})();

```
As you can see the code above the second await cannot Gaurantee the word "Backbencher" is printed which means it is already garbage collected.

Please make sure you use weakref only on the big obj that isn't so important for your program to run.

#### Finalizers

```FinalizationRegistry``` is a companion feature of ```WeakRef```. It lets programmers register callbacks to be invoked after an object is garbage collected.

```jsx
const registry = new FinalizationRegistry((value) => {
  console.log(value);
});
```
Here registry is an instance of FinalizationRegistry. The callback function passed to FinalizationRegistry gets triggered when an object is garbage collected.

```jsx
(function () {

  const obj = {};

  registry.register(obj, "Backbencher");
  // this will passed the value "Backbencher" to registry when obj is garbage collected.
  // and will print "Backbencher" as the output.
})();
```
--- 

### Ergonomic brand checks for Private Fields

```Promise.any()``` resolves if any of the supplied promises is resolved. Below we have 3 promises, which resolves at random times.

```jsx
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => resolve("A"), Math.floor(Math.random() * 1000));
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => resolve("B"), Math.floor(Math.random() * 1000));
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => resolve("C"), Math.floor(Math.random() * 1000));
});
```
Out of ```p1```, ```p2``` and ```p3```, whichever resolves first is taken by ```Promise.any()```.

```jsx
(async function() {
  const result = await Promise.any([p1, p2, p3]);
  console.log(result); // Prints "A", "B" or "C"
})();
```

What if none of the promises resolve? In that case ```Promise.any()``` throws an AggregateError exception. We need to catch it and handle it.

```jsx
const p = new Promise((resolve, reject) => reject());

try {
  (async function() {
    const result = await Promise.any([p]);
    console.log(result);
  })();
} catch(error) {
  console.log(error.errors);
}
```

[Read More](https://github.com/tc39/proposal-promise-any)

---

### New .at() method on all the built-in indexables

The introduction of Numeric Separators will make it easier to read numeric values by using the _ (underscore) character to provide a separation between groups of digits.

Let's look at more examples:

```jsx
1_000_000_000           // Ah, so a billion
101_475_938.38          // And this is hundreds of millions

let fee = 123_00;       // $123 (12300 cents, apparently)
let fee = 12_300;       // $12,300 (woah, that fee!)
let amount = 12345_00;  // 12,345 (1234500 cents, apparently)
let amount = 123_4500;  // 123.45 (4-fixed financial)
let amount = 1_234_500; // 1,234,500
```

[Read More](https://github.com/tc39/proposal-numeric-separator)

---

### Object Accessible Object.prototype.hasOwnProperty()

The ```Intl.ListFormat``` object is a constructor for objects that enable language-sensitive list formatting.

The following example shows how to create a formatted list using the English language.
```jsx
// Create a list formatter in your locale
// with default values explicitly passed in.
const lf = new Intl.ListFormat("en", {
    localeMatcher: "best fit", // other values: "lookup"
    type: "conjunction", // "conjunction", "disjunction" or "unit"
    style: "long", // other values: "short" or "narrow"
});

lf.format(['Motorcycle', 'Truck' , 'Car']);
// > "Motorcycle, Truck, and Car"
```

You are not limited to English, let's try with a few different languages:

```jsx
const list = ['Apple', 'Orange', 'Banana'];

// Italian
console.log(new Intl.ListFormat('it', { style: 'long', type: 'conjunction' }).format(list));
// Apple, Orange e Banana

// Spanish
console.log(new Intl.ListFormat('es', { style: 'long', type: 'conjunction' }).format(list));
// Apple, Orange y Banana

// German
console.log(new Intl.ListFormat('de', { style: 'long', type: 'conjunction' }).format(list));
// Apple, Orange und Banana
```
[Read More](https://github.com/tc39/proposal-intl-list-format)

---

### ECMAScript class static initialization blocks 

We can use ```dateStyle``` and ```timeStyle``` to request a ```locale-specific``` date and time of a given length.

```jsx
// short
new Intl.DateTimeFormat("en" , {
  timeStyle: "short"
}).format(Date.now())
// "2:45 PM"

// medium
new Intl.DateTimeFormat("en" , {
  timeStyle: "medium"
}).format(Date.now())
// "2:45:53 PM"

// long
new Intl.DateTimeFormat("en" , {
  timeStyle: "long"
}).format(Date.now())
// "2:46:05 PM GMT+7"
```

Now let's try with dateStyle:

```jsx
// short
new Intl.DateTimeFormat("en" , {
  dateStyle: "short"
}).format(Date.now())
// "7/25/20"

// medium
new Intl.DateTimeFormat("en" , {
  dateStyle: "medium"
}).format(Date.now())
// "Jul 25, 2020"

// long
new Intl.DateTimeFormat("en" , {
  dateStyle: "long"
}).format(Date.now())
// 
```
[Read More](https://github.com/tc39/proposal-intl-datetime-style)


<p style="text-align:center">🎉🎉That's all for **What's New in Javascript ES2021**! See you next year...🎉🎉</p>
